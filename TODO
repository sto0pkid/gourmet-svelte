* set up initial testing framework (x)
* set up mocking framework (x)
* set up simple widget demos/tests for quick development cycles (x)
* set up initial svelte stuff (x)
* create side-by-side scrolly ingredient view (x)
* define basic API mocks to show how we will retrieve recipe data (x)
* define basic API mocks to show how we will save recipe data (x)
* Mock up basic UI for editing recipe ______ (x)
* Decide on some kind of store/data model. We will eventually need to deal with some significant complexity / support the possibility of auto-save, offline vs. online saving, yada yada yada (x)
* Bind ingredients list the same way you do recprop and rectext (x)
* Simplify the damned data model already (? - maybe did that?) (ish) (x)
* Set up basic code for caching recipe changes / working offline (Hey - that works!) (x)
* Set up faunadb and netlify for testing (x)
* Implement user authentication model (https://docs.fauna.com/fauna/current/tutorials/authentication/user.html)
  -> Actually, we set up netlify identity service as a stand-in... might be worth abstracting this out a bit... presumably we'll change
     identity solutions in time. (x)
  -> Ok, actually, faunadb + GraphQL is kind of a time-suck and then faunadb doesn't support
     custom interfaces anyway and ends up creating a whole bunch of collections for my schema
     which kind of feels like SQL anyway and defeats the whole purpose of using a NoSQL DB, right?
     So I'm switching course to MongoDB. (x)

     - MongoDB seems simple, open source, so far so good.
     - Not sure it's worth using "Mongoose" and schema with it. If I understand it, this puts a bunch
       of validation and stuff in the middle layer. I may regret this later, but since the middle layer
       is the layer I'm potentially paying for, I might rather push validation onto clients where their
       computers can run the logic and keep my netlify function layer as thin as possible.
* initial implementation of a remote recipe db implementation (x)
* Update recipe model to handle syncing to remote DB
  -> Grab from remote DB (x)
     - how to sync the ID's / version #'s... ? (let's just use modified time stamps for now...) (x)
  -> Compare to local DB (x)
  -> Maybe come up with some way to version / avoid grabbing remote data if we don't need to? (x)
* Update display to handle new layout (x)
* Build handy little link conveniences (auto-timers, ingredient highlighter)
  - part way: I have a way to insert custom widgets into code blocks
* Build editor widget types for recipe editing (x)

* Build out chrome extension / translation of react extension for importing recipes
  -> Get svelte compiling into extension (x)
  -> Set up sidebar to communicate with website so we can run ourselves in a sidebar (x)
  -> Set up right-click actions to allow interacting with existing recipes (x)
  -> Set up test harness for moving from magic parser to parsed recipe to import UI (x)
         - Is import UI different from editing UI? How? (x)
         - Is Import UI different from mark-up on the page? How? 

         Option 1: mark-up items on the page, bring them in. Some smarts must be applied in converting marked up text to JSON. (x)
         Option 2: interpret the page directly, some smarts need be applied. (x)

         We generate JSON with a bunch of "pieces" that need to be parsed into items. I guess option three is figuring out how to "add" those pieces. (x)

  -> Set up magic links and stuff (x)
  -> Think through login business... (x)

* Next up:
- Support adding new linked recipes as ingredients (x)
- Make chrome extension a bit more slick...
- Make chrome extension notice when we've already imported a page.
- Add shopping list support
- Improve side-by-side widget code.
- Improve magic ingredient editor code (change on the fly?)
- Sync from local to cloud...
- Export to file





  